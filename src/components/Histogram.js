import React, { Component } from 'react';
import * as d3 from "d3";

class Histogram extends Component {
  state = {
    title:'',
    xLabel:''
  }
  componentDidMount() {
    this.updateState();
    this.createHistogram();
  }
  componentDidUpdate() {
    this.createHistogram();
  }
  updateState = () => {
    if(this.props.dataType==='loyalty') this.setState({
      title:'Party Loyalty',
      xLabel: 'Votes with party (%)'
    });
    if(this.props.dataType==='attendance') this.setState({
      title:'Vote Attendance',
      xLabel: 'Missed votes (%)'
    })
  }
  createHistogram = () => {
    // node in svg element acts as a reference to the actual DOM node generated by React
    const node = this.node;

    // delete previous graphs from toggling between parties (except for total)
    for(let i = 1; i < node.children.length; i++) {
      node.children[i].remove();
    }

    // margins and dimensions
    const margin = {top:20, right:20, bottom: 100, left: 100};
    const graphWidth = 500 - margin.left - margin.right;
    const graphHeight = 400 - margin.top - margin.bottom;

    //create a group for bars, add width/height attributes
    const graph = d3.select(node).append('g')
      .attr('width', graphWidth)
      .attr('height', graphHeight)
      .attr('transform', `translate(${margin.left}, ${margin.top})`)
      .attr('id', this.props.partyMembers.name)

    const xAxisGroup = graph.append('g')
      .attr('transform', `translate(0, ${graphHeight})`);
    const yAxisGroup = graph.append('g');

    this.createAxisLabel(d3.select(node), 'y', graphWidth, graphHeight, margin);
    this.createAxisLabel(d3.select(node), 'x', graphWidth, graphHeight, margin);

    // scales
    const x = d3.scaleLinear().range([0, graphWidth]);
    const y = d3.scaleLinear().range([graphHeight, 0]);

    // create the axes
    const xAxis = d3.axisBottom(x)
      .tickFormat(d => d + '%');
    const yAxis = d3.axisLeft(y);

    const total = this.getData(this.props.dataType, this.props.totalMembers.members);
    const data = this.getData(this.props.dataType, this.props.partyMembers.members);
    const fillColor = this.getFillColor(this.props.partyMembers.name);



    // set number of bins
    const count = 20;

    x.domain(d3.extent(total))
      .nice(count);

    const histogram = d3.histogram()
      .domain(x.domain())
      .thresholds(x.ticks(count));

    // totalBins is used to determine scales for all parties
    const totalBins = histogram(total);
    const bins = histogram(data);

    y.domain([0, d3.max(totalBins.map(bin => bin.length))]);

    const rects = graph.selectAll('rect')
      .data(bins);

    rects.exit().remove();

    this.updateRectangles(rects, x, y, graphHeight, fillColor);
    this.updateRectangles(rects.enter().append('rect'), x, y, graphHeight, fillColor);

    xAxis.ticks(5)
      .tickFormat(d => d + '%')

    xAxisGroup.call(xAxis);
    yAxisGroup.call(yAxis);
  }
  getData = (type, membersArray) => {
    let data = membersArray.filter(m => m.total_votes > 0);

    if(type === 'loyalty') return (
      data.map(m => m.votes_with_party_pct)
    );

    if(type === 'attendance') return (
      data.map(m => m.missed_votes_pct)
    );
  }
  getLoyaltyData = (membersArray) => {
    return (
      membersArray
        .filter(m => m.total_votes > 0)
        .map(m => m.votes_with_party_pct)
        //.filter(m => m !== undefined && m>0 && m<=100)
    );
  }
  getAttendanceData = (membersArray) => {
    console.log(membersArray.length)
    return (
      membersArray
        .filter(m => m.total_votes > 0)
        .map(m => m.missed_votes_pct)
    )
  }
  getFillColor = (party) => {
    switch(party) {
      case 'Total':
        return 'lightgrey';
      case 'Democrats':
        return 'blue';
      case 'Republicans':
        return 'red';
      case 'Independents':
        return 'green';
      default:
        break;
    }
  }
  updateRectangles = (rects, x, y, graphHeight, fillColor) => {
    const t = d3.transition().duration(1000);
    return rects.attr("x", d => x(d.x0)+1)
      .attr("width", d => x(d.x1) - x(d.x0) === 0 ? (0) : (x(d.x1) - x(d.x0)-1))
      .attr("y", graphHeight)
      .attr("height", 0)
      .style("fill", fillColor)
      .transition(t)
        .attr('y', d => y(d.length))
        .attr('height', d => graphHeight - y(d.length))
  }
  createAxisLabel = (node, axis, graphWidth, graphHeight, margin) => {
    let label = node.append("text")
      .attr("text-anchor", "end")
      .attr("font", "10px ariel")
    if(axis === 'y') {
      label.attr("class", "y label")
          .text("Congress members (count)")
          .attr("y", margin.left/2)
          .attr("x", 0-graphHeight/3)
          .attr("transform", "rotate(-90)")
    }
    else if (axis === 'x') {
      label.attr("class", "x label")
        .text(this.state.xLabel)
        .attr("x", graphWidth)
        .attr("y", graphHeight + margin.bottom/1.5)
    }
  }

  render() {
    return (
      <div>
      <h2>{this.state.title}</h2>
      <svg
        ref={node => this.node = node}
        width='500'
        height='400'>
        </svg>
        </div>
    )
  }
}

export default Histogram;
